TDD - 3 perspectives: practice (not best practice, good in some contexts), tool (so can't be dead), strategy (keeps you focused)

London style - good for business apps


Steps:
09:00
- start with a spike to learn the shape of the problem
- strategic design on the board
- hint: use describe/it shortcuts
- super small steps
- destructuring for args
- designing async interfaces
- fake test data, not realistic
- equals, deepEquals
- done pattern vs return promise in mocha
- verifying interactions with pure functions/objects - alternative: mocking library
- test drive getTickersFromFile
- simple tests over awesome test names
- integration tests are scam - combinatorial explosion of cases
- generators - sync looking async code with co-mocha
- given/when/then training wheels
- readFile test
- start with integration test when you don't understand the problem yet
- try/catch for generators
- remember about fail in try
- use integration tests to learn about the problem
- mocking tool - more magic than pure JS code
- extract tickers test
- simple algorithm with no collabs - easy to test. people usually only test those
- move file related functions to file namespace
- write separate tests - DRY in tests is bad advice
- don't use => blindly
- move refactoring in intellij - useful to update require paths
14:30
- get tickers from file
- useful functional utilities: zip - go beyond map/filter/reduce
- listen to your tests and adjust function names
- fetch prices test
- integration tests to learn about HTTP API. statusCode
- skip,xit,only in mocha
- promise all with failing requests
- extract prices test


idea:
- try the same flow for single element. branch out the input
- extract price from response does too much